<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Move a cube</title>
    <script src="js/three.min.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/THREEx.KeyboardState.js"></script>
    <script src="js/THREEx.FullScreen.js"></script>
    <script src="js/THREEx.WindowResize.js"></script>
    <style>
        body {
            background-color: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
            margin: 0 auto;
            top: 50px;
        }

        .score-container {
            /*background-color: red;*/
            position: absolute;
            top: 10px;
            right: 10px;
            transition: transform 0.5s 4s;
        }

        .score-container #score {
            color: white;
            font-size: 8vh;
            font-family: 'Exo', sans-serif;
            font-weight: 700;
        }
    </style>
</head>
<body>
<div class="score-container">
    <div id="score"></div>
</div>
<!--<div id="message" style="color:green; background-color: #a06cc2"></div>-->

<div id="ThreeJS"></div>
<audio src="sound/explode.mp3" preload="auto" id="explode_sound"></audio>


<script>
    // 定义全局变量
    var container, scene, camera, renderer, controls;
    var keyboard = new THREEx.KeyboardState();
    var clock = new THREE.Clock;

    var movingCube;
    var collideMeshList = [];
    var cubes = [];
    var message = document.getElementById("message");
    var crash = false;
    var score = 0;
    var scoreText = document.getElementById("score");
    var id = 0;
    var crashId = " ";
    var lastCrashId = " ";

    init();
    animate();

    function init() {
        // Scene
        scene = new THREE.Scene();
        // Camera
        var screenWidth = window.innerWidth;
        var screenHeight = window.innerHeight;
        camera = new THREE.PerspectiveCamera(45, screenWidth / screenHeight, 1, 20000);
        camera.position.set(0, 170, 400);

        // Renderer
        if (Detector.webgl) {
            renderer = new THREE.WebGLRenderer({antialias: true});
        } else {
            renderer = new THREE.CanvasRenderer();
        }
        renderer.setSize(screenWidth * 0.85, screenHeight * 0.85);
        container = document.getElementById("ThreeJS");
        container.appendChild(renderer.domElement);

        THREEx.WindowResize(renderer, camera);
        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // 加入两条直线
        geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(-250, -1, -3000));
        geometry.vertices.push(new THREE.Vector3(-300, -1, 200));
        material = new THREE.LineBasicMaterial({
            color: 0x6699FF, linewidth: 5, fog: true
        });
        var line1 = new THREE.Line(geometry, material);
        scene.add(line1);
        geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(250, -1, -3000));
        geometry.vertices.push(new THREE.Vector3(300, -1, 200));
        var line2 = new THREE.Line(geometry, material);
        scene.add(line2);


        // 加入控制的cube
        var cubeGeometry = new THREE.CubeGeometry(50, 25, 60, 5, 5, 5);
        var wireMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
        });


        movingCube = new THREE.Mesh(cubeGeometry, wireMaterial);
//            movingCube = new THREE.Mesh(cubeGeometry, material);
//            movingCube = new THREE.BoxHelper(movingCube);
        movingCube.position.set(0, 25, -20);
        scene.add(movingCube);


    }

    function animate() {
        requestAnimationFrame(animate);
        update();
        renderer.render(scene, camera);

    }

    function update() {
        var delta = clock.getDelta();
        var moveDistance = 200 * delta;
        //console.log(moveDistance);
        var rotateAngle = Math.PI / 2 * delta;

//            if (keyboard.pressed("A")) {
//                camera.rotation.z -= 0.2 * Math.PI / 180;
//                console.log("press A")
//            }
//            if (keyboard.pressed("D")) {
//                movingCube.rotation.y += rotateAngle;
//            }

        if (keyboard.pressed("left") || keyboard.pressed("A")) {
            if (movingCube.position.x > -270)
                movingCube.position.x -= moveDistance;
            if (camera.position.x > -150) {
                camera.position.x -= moveDistance * 0.6;
                if (camera.rotation.z > -5 * Math.PI / 180) {
                    camera.rotation.z -= 0.2 * Math.PI / 180;
                }
            }
        }
        if (keyboard.pressed("right") || keyboard.pressed("D")) {
            if (movingCube.position.x < 270)
                movingCube.position.x += moveDistance;
            if (camera.position.x < 150) {
                camera.position.x += moveDistance * 0.6;
                if (camera.rotation.z < 5 * Math.PI / 180) {
                    camera.rotation.z += 0.2 * Math.PI / 180;
                }
            }
        }
        if (keyboard.pressed("up") || keyboard.pressed("W")) {
            movingCube.position.z -= moveDistance;
        }
        if (keyboard.pressed("down") || keyboard.pressed("S")) {
            movingCube.position.z += moveDistance;
        }

        if (!(keyboard.pressed("left") || keyboard.pressed("right") ||
                keyboard.pressed("A") || keyboard.pressed("D"))) {
            delta = camera.rotation.z;
            camera.rotation.z -= delta / 10;
        }


        var originPoint = movingCube.position.clone();

        for (var vertexIndex = 0; vertexIndex < movingCube.geometry.vertices.length; vertexIndex++) {
            // 顶点原始坐标
            var localVertex = movingCube.geometry.vertices[vertexIndex].clone();
            // 顶点经过变换后的坐标
            var globalVertex = localVertex.applyMatrix4(movingCube.matrix);
            var directionVector = globalVertex.sub(movingCube.position);

            var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
            var collisionResults = ray.intersectObjects(collideMeshList);
            if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
                crash = true;
                crashId = collisionResults[0].object.name;
                break;
            }
            crash = false;
        }

        if (crash) {
//            message.innerText = "crash";
            movingCube.material.color.setHex(0x346386);
            console.log("Crash");
            if (crashId !== lastCrashId) {
                score -= 100;
                lastCrashId = crashId;
            }

            document.getElementById('explode_sound').play()
        } else {
//            message.innerText = "Safe";
            movingCube.material.color.setHex(0x00ff00);
        }

        if (Math.random() < 0.03 && cubes.length < 30) {
            makeRandomCube();
        }

        for (i = 0; i < cubes.length; i++) {
            if (cubes[i].position.z > camera.position.z) {
                scene.remove(cubes[i]);
                cubes.splice(i, 1);
                collideMeshList.splice(i, 1);
            } else {
                cubes[i].position.z += 10;
            }
//                renderer.render(scene, camera);
        }

        score += 0.1;
        scoreText.innerText = "Score:" + Math.floor(score);

        //controls.update();
    }


    // 返回一个介于min和max之间的随机数
    function getRandomArbitrary(min, max) {
        return Math.random() * (max - min) + min;
    }

    // 返回一个介于min和max之间的整型随机数
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }


    function makeRandomCube() {
        var a = 1 * 50,
                b = getRandomInt(1, 3) * 50,
                c = 1 * 50;
        var geometry = new THREE.CubeGeometry(a, b, c);
        var material = new THREE.MeshBasicMaterial({
            color: Math.random() * 0xffffff,
            size: 3
        });


        var object = new THREE.Mesh(geometry, material);
        var box = new THREE.BoxHelper(object);
//            box.material.color.setHex(Math.random() * 0xffffff);
        box.material.color.setHex(0xff0000);

        box.position.x = getRandomArbitrary(-250, 250);
        box.position.y = 1 + b / 2;
        box.position.z = getRandomArbitrary(-800, -1200);
        cubes.push(box);
        box.name = "box_" + id;
        id++;
        collideMeshList.push(box);

        scene.add(box);
    }

</script>
</body>
</html>